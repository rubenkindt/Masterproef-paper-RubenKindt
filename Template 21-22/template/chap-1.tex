%Ideas 
%context
%	what is CP and family, \cite{freuder1997pursuit}
%	usage
%	what could go wrong
%
%
%bit of history around fuzzing or CP?
% first study in fall of 1988 paper in 1990
% miller 2020 heeft hiervoor de start aan bronnen, pagina 2 middel of linker kolomn
%	generation based, mutation based | White grey, back box | directed fuzzing, coverage-based fuzzing \cite{11Fuzzingasurvey}
%
%
%Chapter about (psuedo-)randomness
%seed selection problem, inf seeds which one do we use
%
%chapeter on simplifying the crashes
%	binary search will not work all the time
%	quarters remove may work (if all parts fail go more granular, 1/9 or 1/16)
%		start with halfs then *2
%		always search further with same granularity but with removed part until all options with that granularity searched \cite{zeller2009programs} p111
%		this uses no knowledge from input structure and program structure \cite{zeller2009programs} p112
%	delta debugging
%		time spend searching vs simplified ratio is important as mentioned in \cite{mansur2020detecting}
%		and needs to preserve satisfiability as mentioned in \cite{mansur2020detecting}
%		^ possibly a big deal to find critical bugs
%
%	with knowadge of input, syntax \cite{zeller2009programs}
%	of by bigger entities like lines of words \cite{zeller2009programs}
%	 for speed
%
%	alt approach like \cite{mansur2020detecting} try finding the bug again with less resources avail
%	or isolaytion \cite{zeller2009programs} p 285 
%		I think it may fail if multiple parts are relevant
%		I think it could detect for example the CPMpy import as a bug cause as the min diff that causes the bug
%
%	sub section on MUS/minimum unsat subset vs delta debugging
%		MUs good for only whole constraints while 
%		delta debugging goes for partial structures
%
%	section on how CPMpy works and convorts for other solvers \cite{CP2021 Tutorial "CPMpy, a Numpy-based CP Modeling Environment} and \cite{https://github.com/CPMpy/cpmpy/} and where errors could occure, whitch ones are in/out of scope
%
%	%dedublication techniques: stack backtrace (hashing), coverage beased, semantics aware \cite{13manes2019survey}
%	isolation vs simplifying \cite{zeller2009programs} p 285
%
%if inf seed set, reducing it is better with the following technique (the min seed subset without any code coverage loss) \cite{14rebert2014seedselecting}
%
%avoiding inf loops -> timeouts
%The Precision Effect minimizing/simplyfying may lead to a dif found bug if multiple, since all need to be solved not problem  \cite{zeller2002simplifying}
%	 can be sloved with stack trace comparison
%
%section on minimalisation vs isolation \cite{zeller2002simplifying} p12
%	for speed take smaller inputs
%	Isolation will require a lot more things to track but is faster
%	
%Chapter around fuzzing
%	\cite{mathis2019parser} states 3 optins traditional, stochastic and syntax driven.
%
%chapter results
%chapter comparison to other fuzzers
%

\chapter{The First Chapter}
\label{cha:1}
A chapter is a logical unit. It normally starts with an introduction, which
you are reading now. The last topic of the chapter holds the conclusion.

\section{The First Topic of the Chapter}
First comes the introduction to this topic.

\lipsum[55]

\subsection{An item}
Please don't abuse enumerations: short enumerations shouldn't use
``\verb|itemize|'' or ``\texttt{enumerate}'' environments.
So \emph{never write}: 
\begin{quote}
  The Eiffel tower has three floors:
  \begin{itemize}
  \item the first one;
  \item the second one;
  \item the third one.
  \end{itemize}
\end{quote}
But write:
\begin{quote}
  The Eiffel tower has three floors: the first one, the second one, and the
  third one.
\end{quote}

\section{A Second Topic}
\lipsum[64]

\subsection{Another item}
\lipsum[56-57]

\section{Conclusion}
The final section of the chapter gives an overview of the important results
of this chapter. This implies that the introductory chapter and the
concluding chapter don't need a conclusion.

\lipsum[66]

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
