\chapter{Results}
\label{cha:res}
\label{res:Intro}
\todo{intro ch 6}

\section{Running the tests}
\label{res:RunningTests}
\label{res:Specs}
Although the specifications are not crucial since we did not do any speed benchmarking, it does give you, the reader, an idea of the performance. All tests where executed on an Ubuntu 20.04.5 LTS with 8GB RAM, an Intel core i5-3380M capable of 2.90GHz and a V-NAND SSD of 500GB 860 EVO Model MZ-76E500 through a SATA 3 connection. With each technique taking around a day to three days to run all nine thousand seed files once. Note that processing a seed once can mean that variants of that seed were run up to 100 times depending on the technique.

%time when faults are found?

\subsection{Preventing the same bug from occurring frequently}
%these tools often gave the same error again causing the new bug to be hidden, se choice to catch some of the more prevelent bugs, If some one wishes to rerun (parts) It is best to remove those exceptions in order to see the full output
While the techniques where running noticed that once a bug was found by any of our techniques that same bug would occur frequently but in a different seed, causing our resulting logs to be cluttered with duplicates bugs. We where aware that this could occur and we originally wanted to use deduplication as described in subsection \ref{inputReduction:Deduplication} to get rid of the duplicates. But after seeing 10 000 logs of the same bug, we changed from a reactive approach to a preventative approach. Once we noted a bug we tried to prevent it, for crashes this meant adding a try catch for the specific error. While, for wrongly (un)satisfiable we looked at special occurrences of keywords in constraint we knew caused bugs to then not log them. For example a bug we will discuss soon had a specific string of characters " == 0 == 0" making any problem wrongly unsatisfy. Being able to check the string of characters with knowing that it resulted in wrongly unsatisfiable  solutions made it for able for us to filter that bug as well. Luckily, with these restrictions on the output logs we were able to filter out most duplicate bugs, this is not an ideal solution but seems to work for now. The ideal solution would be that the fuzzer has knowledge of the already found bugs and reject them, techniques like these do exist but would bring us to far from the scope of the dissertation. Although, less efficient the techniques could be used for detecting an error fixing them and then rerunning for the next bug instead of adding exceptions.

\section{Results: found bugs}
\label{res:bugs}
In total we found 20 bugs, three of which were already submitted as an issue. Of those bugs some of them where easy fixes, some were a bit harder and required more time to solve. At the time of writing not al bugs are resolved (some are just reported days ago), but we look in anticipation how those will be solved. For now let's look at some of the most interesting bugs we found. In order to do this we will work with the four components we defined earlier in subsection \ref{CP:CPMpy}, this being: the model, the transformations, the solver specific transformations and the solvers themselves as seen in figure \ref{fig:4ComponentsOfCPMpy}.


\subsection{Double Not}
\label{res:bug:DoubleNot}
The first bug we discovered was our "double not"-bug, a bug where we ask CPMpy to solve the constraints "X==3 and not(not(X==3))". Clearly this solution is trivial, set variable 'X' equal to 3 and the problem would be satisfied. However not all CPMpy solver did agreed with this, both OR-Tools and Gurobi said that this problem was unsatisfiable. 

This was due to a process within CPMpy responsible for creating a flat normal form. Not all solver used by CPMpy allow an arbitrary nesting of constraints as described by the documentation of CPMpy\footnote{\url{https://cpmpy.readthedocs.io/en/latest/behind_the_scenes.html}}. It is for that reason that CPMpy flattens the constraints to what they call 'flat normal forms' as the similar definition of SAT but with a disclaimer that this definition does not formally exists for CP languages to their knowledge, a statement which we agree with. With this flattened form CPMpy can directly call the solvers or do some solver specific transformations on the flattened constraints to then send it to the respective solver \cite{CPMpyGithub}. 

It was in this normalizing process that a comparison in a comparison was not handled (a 'not' gets translated to a comparison with zero "== 0"). Causing a disappearance of a single "not", which in turn resulted in "X==3 and not(X==3)" being send to OR-Tools and Gurobi. The other solvers, mainly MiniZinc's subsolvers, where not affected by this bug due to not using this normalizing process. Although, this normalizing process was subjected to unit tests, these tests contained an incorrect output causing the bug to remain under the radar. This bug was only caught using the modified STORM technique, due to its frequent use of adding "not"'s and "and"'s. But we believe it could have been caught in the differential testing if one of the seeds had a double not in its constraints or in the metamorphic testing if we had though of adding a relevant metamorphic transformation. The bug can be found in the GitHub repository issue number  142\footnote{\url{https://github.com/CPMpy/cpmpy/issues/142}}.

\subsection{Negation of Global functions}
\label{res:bug:NegatedGlobal}
A second bug related to the use of "not"'s were the crashes of the negated global functions. For example, "not(AllDifferent(argList))" would crash with a maximal recursion depth as the normalizing of a negated global function would be handled with adding a "== 0" to it, instead of decomposing the global function and negating that. The action of adding a "== 0" did not change the constraint and on the next normalizing of the left part of the comparison "global function == 0", the same would happen. The solution was as mentioned to decomposing the global function, which was suggested in the comments together with a commented out not-implemented warning. The entire function was labeled as work in progress, but the CPMpy-team expected it to work for this use case as they used it in their reification process. With a small but important caveat that this bug took a shortcut in the code, therefore exposing the bug. 

It was again due to the normalizing not being used for MiniZinc's subsolvers that the bug only occurred when using OR-Tools and Gurobi as solvers. This bug was quickly found by our modified STORM since it uses a significant number of "not"'s. It did not get found by our differential tests simply because no examples negated their global functions as such a negation is rarely useful. However, due to adding "!= 0" after constraints the metamorphic tests did find it as the bug as well. The bug can be found in the GitHub repository issue number  143\footnote{\url{https://github.com/CPMpy/cpmpy/issues/143}}.

\subsection{Power function of Gurobi}
\label{res:bug:Power}
Now that we have seen two bugs in the normalization part of CPMpy, which both fit in the transformations component of CPMpy. It is time to look at some solver specific transformations and some bugs we found there. A first one was a bug where the solver Gurobi would crash if we gave a base variable in the power function which had a negative lower bound. A lower bound meaning that the variable was not permitted lower that that bound. All other solver would be able to solve "pow(X, 2) == 9" with the variable 'X' defined with a lower bound of -5 and a higher bound of 5. But Gurobi does not allow this and throws an error.

This bug was found with our modified STORM implementation because there was a seed file which contained this power function with a negative lower bound in the base. However, the solver used to solve this problem was not Gurobi meaning that the bug was not discovered when written. The problem can be found at the CPMpy repository's csplib examples\footnote{\url{https://github.com/CPMpy/cpmpy/blob/b60310d7962bc7631bcf0b9024140e47c1fb302e/examples/csplib/prob005_auto_correlation.py}} and was written by Ignace Bleukx. We do not think that our modified STORM would have found it if it was not in the seed file to begin with, since our modified STORM does not create new variables nor modifies any lower bounds of variables. Since the problem was already in the seed file our differential testing did report it, but not by our metamorphic tester. We believe if we had written a metamorphic relation for the power function or one where we changed some bounds of variables that we could have found this bug with this technique. The bug can be found in the GitHub repository issue number 149\footnote{\url{https://github.com/CPMpy/cpmpy/issues/149}}.

\subsection{Wrong bound value Error}
\label{res:bug:WrongBounds}
A second bug we found in the solver specific transformations was a missing check on the variable type, this time not in Gurobi but in the PySAT implementation. When asking for a check if a sum of booleans matches a specific variable and that variable happens to be an integer instead of a boolean naturally the SAT solver, which only support boolean satisfiability problems, will complain. In this specific case it was a follow-up function still within CPMpy that crashed with wrong bounds since it expected a bound of only two possibilities. On all other places we could find a not implemented with explanation would be thrown, but on this spot it was missed. After reporting it the bug was quickly fixed.

Although, our modified STORM was run with PySAT's subsolvers it did not find this bug simply due to a check of (un)satisfiablility at the start of the program. This check would crash PySAT's subsolvers since almost all seeds where written with a CP solver in mind. Some problems would pass since CPMpy tries its best to transform CP constraints to SAT constraints, but this was a minority. The bug did get discovered with the differential tester where each crash did get logged on top of the differences. And again with the metamorphic tests we needed to know the (un)satisfiablility of the model before the changes, when it would crash we would try another solver. Since those crashes were not logged we did not find it with this technique. The bug can be found in the GitHub repository issue number 150\footnote{\url{https://github.com/CPMpy/cpmpy/issues/150}}.

%\subsection{Circuit of one} % remove this bug from the txt ?
%\label{res:bug:Circuit}
%On top of bugs related to specific solver or a group of solvers treated differently like the first two bugs. We also found bugs that would be thrown unrelated to which solver was used to solve the problem. Which brings us to the bug where we discovered that creating a global function, namely circuit, with only one entry would it crash with a not subscriptable error. This bug can be seen as an user caused error and be dismissed, but the CPMpy-team agreed saw it the same way. They marked it as a bug and added a small check.
%
%\todo{which fuzzers found it?}
%
%This bug can be found in the GitHub repository issue number  157\footnote{\url{https://github.com/CPMpy/cpmpy/issues/157}}.

\subsection{Naming variables}
\label{res:bug:Naming+andImport}
Now that we have seen bugs occur in both the Transformation and the solver specific transformations let's look at a bug we have found in the model component of CPMpy. 

CPMpy has multiple features like importing, exporting models, adding names variables (not to be confused with the local variables as seen on line 12 in listing \ref{lst:SendMoreMoneyCPMpy}) and others. The adding of the name is to make sure that after an export and import or the given variable names are still remembered among others reasons like to be able to give the solver the variable names. When the programmer does not give a name to a variable as we can see on line 12 in listing \ref{lst:SendMoreMoneyCPMpy} with the missing "name='somename'" in the "intvar" function. Then CPMpy adds a name to the variable without telling the programmer starting with "BV" for boolean variables and "IV" with integer variables and appends an incrementing number to not have similar names. Since reusing variable names is dangerous When the solvers use this name to differentiate variables from each other.
\todo{is dit slecht uitgelegd?}

This brings us to the bug, it occurs when importing a model where automatic naming was done that the counter was still at zero. Meaning that when a new variable was created with automatic naming it would have an overlapping variable name with a variable that was imported. When a solver was then called it would treat both variables as the same resulting in potential wrongly unsatisfiable solutions. The use case is a bit farther from the normal use case a programmer would go thorough. Nevertheless, this was not considered a misuse of CPMpy according to the developers and at the time of writing a pull request got proposed in which the import function got extended to check the highest occurrence of the boolean and integer counter. This highest occurrence will be used for the counters.

A similar and almost related bug is naming the variables starting with strange symbols like '+', '\%' or others. Most solver would solve happily work with these names and solve lake nothing happens, but all MiniZinc's subsolvers crashed with a syntax error when handling the input. Due to transformation of our model to the text-base FlatZinc for the subsolver, it can no longer differentiate between the variable name and the code. It therefore crashes when seeking anything that could be interpreted differently then a variable name. MiniZinc does state that identifiers  are not allowed to contain special characters, which CPMpy did allow. A solution is still being discussed at the time of writing.


Both of these bugs where not caught by our modified STORM nor the differential testing, since they do not create new variables. But were caught by our metamorphic testing, the first one because we imported a seed file where automatic naming was done which we did too inside our tester, causing the bug. the second one is a bit more embarrassing to write about since we create a bug in the metamorphic tester witch resulted in (unintentionally) creation of variables starting with a '+'. We sill label is as caught by this tester because it did find it, although accidentally. The bugs can be found in the GitHub repository issue number 158\footnote{\url{https://github.com/CPMpy/cpmpy/issues/158}} and 162\footnote{\url{https://github.com/CPMpy/cpmpy/issues/162}} respectively.



%\subsection{Unsatisfiable Gurobi} % boring bug
%\label{res:bug:UnsatGurobu}
%Our last bug we will discuss is a bug that was found by all three techniques
%
%
%This bug can be found in the GitHub repository issue number  168\footnote{\url{https://github.com/CPMpy/cpmpy/issues/168}}.





\section{Classifications}
\subsection{Model, Transformation or Solver}

\begin{table}[]
	\centering
	\begin{tabular}{lll}
	BugNr & Bug description                                         & Place of the bug \\ \toprule
	142   & double not gives unsat                                  & Transformation   \\
	143   & negating global functions crashes                       & Transformation   \\
	145   & solvers lookup crashes                                  & Model            \\
	149   & power function with negative lower bound crashes        & Solver           \\
	150   & wrong bound gives causes a crash                        & Solver           \\
	152   & boolean variable does not support implies               & Model            \\
	153   & Gurobi does not run and gives the wrong nr of sol       & Solver           \\
	154   & JSON Decoder error                                      & Solver           \\
	155   & list has no shape                                       & solver           \\
	156   & MiniZinc returns zero causes a crash                    & Solver           \\
	157   & Circuit of one element crashes                          & Transformation   \\
	158   & Identical variable name can cause wrongly unsat         & Model            \\
	159   & Unhandled Gurobi exit status 9                          & Solver           \\
	161   & two separate references for the same variable           & Model            \\
	162   & CPMpy is looser with variable names than MiniZinc       & Solver           \\
	163   & Cyclic expression tee got generated                     & Model            \\
	164   & malloc() failure due to unset bounds                    & Transformation   \\
	165   & memory violation segmentation fault                     & Transformation   \\
	168   & unsatisfiable Gurobi                                    & Transformation   \\
	170   & unsatisfiable due to flattening                         & Transformation   \\ \bottomrule        
	\end{tabular}
	\caption{A table with the correct layout.}
	\label{tab:bug:place}
\end{table}

Tabel + bespreken
\subsection{crash or wrongly (un)sat}
\begin{table}[]
	\centering
	\begin{tabular}{lll}
		BugNr & Bug description                                           & Type of fault   \\ \toprule
		142   & double not gives unsat                                    & wrongly unsat   \\
		143   & negating global functions crashes                         & crash           \\
		145   & solvers lookup crashes                                    & crash           \\
		149   & power function with negative lower bound crashes          & crash           \\
		150   & wrong bound gives causes a crash                          & crash           \\
		152   & boolean variable does not support implies                 & crash           \\
		153   & Gurobi does not run and gives the wrong nr of sol         & did not run     \\
		154   & JSON Decoder error                                        & crash           \\
		155   & list has no shape                                         & crash           \\
		156   & MiniZinc returns zero causes a crash                      & crash           \\
		157   & Circuit of one element crashes                            & crash           \\
		158   & Identical variable name can cause wrongly unsat           & wrongly unsat   \\
		159   & Unhandled Gurobi exit status 9                            & crash           \\
		161   & two separate references for the same variable             & wrongly unsat   \\
		162   & CPMpy is looser with variable names than MiniZinc         & crash           \\
		163   & Cyclic expression tee got generated                       & crash           \\
		164   & malloc() failure due to unset bounds                      & crash           \\
		165   & memory violation segmentation fault                       & crash           \\
		168   & wrongly unsatisfiable Gurobi                              & wrongly unsat   \\
		170   & wrongly (un)satisfiable due to flattening                 & wrongly (un)sat \\ \bottomrule
	\end{tabular}
	\caption{A table with the correct layout.}
	\label{tab:bug:fault}
\end{table}

Tabel + bespreken
\subsection{which solver}
\begin{table}[]
	\centering
	\begin{tabular}{lll}
		BugNr & Bug description                                           & Which solver caused it?\\ \toprule
		142   & double not gives unsat                                    & OR-Tools and Gurobi                            \\
		143   & negating global functions crashes                         & OR-Tools and Gurobi                            \\
		145   & solvers lookup crashes                                    & solver independent                             \\
		149   & power function with negative lower bound crashes          & Gurobi                                         \\
		150   & wrong bound gives causes a crash                          & all pysat subsolvers                           \\
		152   & boolean variable does not support implies                 & solver independent                             \\
		153   & Gurobi does not run and gives the wrong nr of sol         & Gurobi                                         \\
		154   & JSON Decoder error                                        & MiniZinc's subsolver osicbc                    \\
		155   & list has no shape                                         & Gurobi                                         \\
		156   & MiniZinc returns zero causes a crash                      & multiple MiniZinc subsolvers                   \\
		157   & Circuit of one element crashes                            & solver independent                             \\
		158   & Identical variable name can cause wrongly unsat           & solver independent                             \\
		159   & Unhandled Gurobi exit status 9                            & Gurobi                                         \\
		161   & two separate references for the same variable             & solver independent                             \\
		162   & CPMpy is looser with variable names than MiniZinc         & all MiniZinc subsolvers                        \\
		163   & Cyclic expression tee got generated                       & solver independent                             \\
		164   & malloc() failure due to unset bounds                      & multiple MiniZinc subsolvers                   \\
		165   & memory violation segmentation fault                       & multiple MiniZinc subsolvers                   \\
		168   & wrongly unsatisfiable Gurobi                              & Gurobi                                         \\
		170   & wrongly (un)satisfiable due to flattening                 & OR-Tools and Gurobi                            \\ \bottomrule
	\end{tabular}
	\caption{A table with the correct layout.}
	\label{tab:bug:Solver}
\end{table}

Tabel + bespreken
\subsection{which technique could find it}
Tabel + bespreken
\begin{table}[]
	\centering
	\begin{tabular}{lllll}
		BugNr & Bug description                                           & \multicolumn{3}{l}{Found by which technique} \\ \toprule
		142   & double not gives unsat                                    & storm          &              &              \\
		143   & negating global functions crashes                         & storm          &              & meta         \\
		145   & solvers lookup crashes                                    &                & diff         &              \\
		149   & power function with negative lower bound crashes          & storm          & diff         &              \\
		150   & wrong bound gives causes a crash                          &                & diff         &              \\
		152   & boolean variable does not support implies                 &                & diff         & meta         \\
		153   & Gurobi does not run and gives the wrong nr of sol         &                & diff         &              \\
		154   & JSON Decoder error                                        & storm          & diff         & meta         \\
		155   & list has no shape                                         & storm          & diff         & meta         \\
		156   & MiniZinc returns zero causes a crash                      & storm          & diff         & meta         \\
		157   & Circuit of one element crashes                            &                &              & meta         \\
		158   & Identical variable name can cause wrongly unsat           &                &              & meta         \\
		159   & Unhandled Gurobi exit status 9                            & storm          & diff         &              \\
		161   & two separate references for the same variable             & storm          &              & meta         \\
		162   & CPMpy is looser with variable names than MiniZinc         &                &              & meta         \\
		163   & Cyclic expression tee got generated                       &                &              & meta         \\
		164   & malloc() failure due to unset bounds                      &                &              & meta         \\
		165   & memory violation segmentation fault                       &                & diff         & meta         \\
		168   & wrongly unsatisfiable Gurobi                              & storm          & diff         & meta         \\
		170   & wrongly (un)satisfiable due to flattening                 & storm          &              & meta         \\ \bottomrule
	\end{tabular}
	\caption{A table with the correct layout.}
	\label{tab:bug:Technique}
\end{table}


\section{Reception to the bugs}
they where happy :p
The double Not bug \ref{res:bug:DoubleNot} was called a serious bug and a great find. % https://github.com/CPMpy/cpmpy/issues/142#issuecomment-1312530262

\ref{res:bug:NegatedGlobal}
unexpected bug as the code is used often in reification, but this used a shortcut
% https://github.com/CPMpy/cpmpy/issues/143#issuecomment-1312522873


\section{STORM}
Techniques are best applied during development, since the modified storm of to often detects the already fond bugs

conclusion? 
working with seeds does limit us

%problems limited by global fucntions of used seeds (somewhat fine),
%only 'and' and 'not' combinations Just like STORM

~(~(True))
~(global function)
\section{Differential testing}
solverlookup()  was during development = manual testing, 

\section{Metamorphic testing}
did not find ~(~()) simly because we dind't think to check it specificly, we did check ~=0
all checks ? + combo-able

maybe for conclusion
manual written (= work, although not much work), own choice on how complex you make the relations(simple ones work too), still need the creativity, all relations seem to be "why would this crash this is pointless to write" but do crash sometimes

\section{YinYang}


\section{unsat}
due to the way of importing the file a lot of edge problems become sat or unsat

\section{woringly sat}
meta unsat minizinc 0
to shirk this we used the fact that ortools+gurobi (probably) gave the correct solution, this being unsat and taking the mus from that


\subsection{finding mus}
combination of their tool, but when we got errors from the different way of loading, We used my tool and then theirs. general combinations were done got get a minimal. 
my tool incapable of pure MUS

circuit bug: error -> not mus, but ours + a bit manuel



\section{Conclusion}
\todo{Conclusion}
The final section of the chapter gives an overview of the important results
of this chapter. This implies that the introductory chapter and the
concluding chapter don't need a conclusion.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
