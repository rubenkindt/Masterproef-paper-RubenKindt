\chapter{Introduction}
\label{cha:intro}
There are a lot of causes for bugs: software complexity, multiple people writing different parts, changing objective goals, misaligned assumptions and more. Most these things can not be avoided during the creation of software but are the cause of program crashes, vulnerabilities or wrong outcomes. Multiple forms of prevention have been created like: the various forms of software testing, documentation, automatic tests and code reviews. All with the aim to prevent the occurrence of bugs and to reduce the cost associated with them. While automatic test cases often evaluate the goals of software end evaluate previous known bugs, it can do much more. Fuzzing software is a part of those automatic tests, a technique that is popular in the security world for exploit prevention. This technique generates random input for a program under test (PUT) and monitors if the program crashes or not. This explanation was the original interpretation of fuzzing as preformed by Miller\cite{4originalFuzzingUnixUtils}, today this technique is seen as random  generation based black box fuzzing while the current fuzzing envelops a broader term, as Man\`es et al.\cite{13manes2019survey} put it nicely:
\begin{quote}
"Fuzzing refers to a process of repeatedly running a program with generated inputs that may be syntactically or semantically malformed."
\end{quote} as quoted from \cite{13manes2019survey}.

With this technique we will try to detect bugs in the constraint programming and modeling library CPMpy \cite{17guns2019increasing} created by Prof. dr. Guns et al.

\todo{modus operandi bij intro}

\section{The place of fuzzers in the software development cycle}
During the development phase of software, tests are preformed to check if the written code matches the expected and wanted output. This can be done by the developers themselves or by quality assurance testers which do this full time and this on multiple different ways: code review, manual testing or automated testing. Those could exist out of unit tests, checking for known bugs, confirming that the use cases are working, code audits and fuzzing. This last one is on the rise in popularity.


% + it is only a part of the testing sweet 

\section{Fuzzing and security}
shellchock found with afl
heartbleed could have been found using AFL 



\section{Constraint programming in general}
%	what is CP and family, differences, \cite{freuder1997pursuit}
%	usage
%	what could go wrong, cost of bugs

\section{CPMpy}
%	section on how CPMpy works and convorts for other solvers \cite{CP2021 Tutorial "CPMpy, a Numpy-based CP Modeling Environment} and \cite{https://github.com/CPMpy/cpmpy/} and where errors could occure, whitch ones are in/out of scope

\section{fuzzing history}
% why fuzzing, ref to securrity and \cite{25MillerOnMacOS} examples of viruese
%bit of history around fuzzing or CP?
% first study in fall of 1988 paper in 1990
% miller 2020 heeft hiervoor de start aan bronnen, pagina 2 middel of linker kolomn
%	generation based, mutation based | White gray, back box | directed fuzzing, coverage-based fuzzing \cite{11Fuzzingasurvey}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
