%written in USA's English
\documentclass[master=cws, masteroption=se, english, oneside]{kulemt} % oneside
\setup{% Verwijder de "%" op de volgende lijn bij UTF-8 karakterencodering
  inputenc=utf8,
  title={Fuzz Testing of Constraint Programming}, 
  author={ing. Ruben Kindt},
  promotor={Prof.\, dr.\ Tias Guns},
  assessor={ },
  assistant={Ir. Ignace Bleukx}
}
% Detecting bugs in constraint programming languages
% Fuzz testing constraint programming languages
% Lifting combinatorial fuzz testing for constraint programming languages


% Verwijder de "%" op de volgende lijn als je de kaft wil afdrukken
%\setup{coverpageonly}
% Verwijder de "%" op de volgende lijn als je enkel de eerste pagina's wil
% afdrukken en de rest bv. via Word aanmaken.
%\setup{frontpagesonly}

% Kies de fonts voor de gewone tekst, bv. Latin Modern
\setup{font=lm}

% Hier kun je dan nog andere pakketten laden of eigen definities voorzien
%\usepackage{todonotes}
\usepackage{xcolor}
\usepackage{pifont}   % used for checkmarks
\usepackage{listings} % used for code listings
\usepackage{csquotes} % makes sure that the quotes follow the same typeset as the rest of the text
%\usepackage[tableposition=top]{caption} % caption above table
\usepackage[margin=10pt,font=small,labelfont=bf,labelsep=endash, tableposition=top]{caption}

\usepackage{float}

%thanks to https://github.com/youngkd/MSPSP-InstLib/blob/master/format-description.tex
%----------------------------------------------%
% Syntax highlighting for MiniZinc in listings %
%----------------------------------------------%
\definecolor{ForestGreen}{RGB}{34,106,46}
\definecolor{VeryLightGrey}{RGB}{230,230,230}
\usepackage{color}
\lstdefinelanguage{minizinc}{
	morekeywords={
		%% MiniZinc keywords
		%%
		ann, annotation, any, array, assert,
		bool,
		constraint,
		else, elseif, endif, enum, exists,
		float, forall, function,
		if, in, include, int,
		list,
		minimize, maximize,
		of, op, output,
		par, predicate,
		record,
		set, solve, string,
		test, then, tuple, type,
		var,
		where,
		%% MiniZinc functions
		%%
		abort, abs, acosh, array_intersect, array_union,
		array1d, array2d, array3d, array4d, array5d, array6d, asin, assert, atan,
		bool2int,
		card, ceil, combinator, concat, cos, cosh,
		dom, dom_array, dom_size, dominance,
		exp,
		fix, floor,
		index_set, index_set_1of2, index_set_2of2, index_set_1of3, index_set_2of3, index_set_3of3,
		int2float, is_fixed,
		join,
		lb, lb_array, length, let, ln, log, log2, log10,
		min, max,
		pow, product,
		round,
		set2array, show, show_int, show_float, sin, sinh, sqrt, sum,
		tan, tanh, trace,
		ub, and ub_array,
		%% Search keywords
		%%
		bool_search, int_search, seq_search, priority_search,
		%% MiniSearch keywords
		%%
		minisearch, search, while, repeat, next, commit, print, post, sol, scope, time_limit, break, fail
	},
	sensitive=true, % are the keywords case sensitive
	morecomment=[l][\em\color{ForestGreen}]{\%},
	%morecomment=[s]{/*}{*/},
	morestring=[b]",
}
%% Settings for listings
%%
\lstset{ %
	backgroundcolor=\color{VeryLightGrey},  % choose the background color; you must add
	% \usepackage{color} or \usepackage{xcolor}
	basicstyle=\scriptsize\ttfamily,    % the size of the fonts that are used for the code
	belowskip=0em,
	breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
	breaklines=true,                    % sets automatic line breaking
	captionpos=b,                       % sets the caption-position to bottom
	commentstyle=\color{ForestGreen},   % comment style
	%deletekeywords={...},              % if you want to delete keywords from the given language
	escapeinside={\%*}{*)},             % if you want to add LaTeX within your code
	extendedchars=true,                 % lets you use non-ASCII characters; for 8-bits
	% encodings only, does not work with UTF-8
	frame=single,                       % adds a frame around the code
	keepspaces=true,                    % keeps spaces in text, useful for keeping indentation
	% of code (possibly needs columns=flexible)
	keywordstyle=\bfseries\color{blue}, % keyword style
	language=minizinc,                  % the language of the code
	%morekeywords={*,...},              % if you want to add more keywords to the set
	numbers=left,                       % where to put the line-numbers; possible values are (none, left, right)
	%numbersep=5pt,                     % how far the line-numbers are from the code
	%numberstyle=\tiny\color{Gray},     % the style that is used for the line-numbers
	rulecolor=\color{black},            % if not set, the frame-color may be changed
	% on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                   % show spaces everywhere adding particular
	% underscores; it overrides 'showstringspaces'
	showstringspaces=false,             % underline spaces within strings only
	showtabs=false,                     % show tabs within strings adding particular underscores
	%stepnumber=1,                      % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{purple},            % string literal style
	tabsize=2,                          % sets default tabsize to 2 spaces
	title=\lstname                      % show the filename of files included with \lstinputlisting;
	% also try caption instead of title
}

%\usepackage[style=numeric,sortcites,sorting=nty,backref,hyperref]{biblatex}
%\usepackage[style=numeric,sortcites,sorting=none,backref,hyperref]{biblatex} % no sort, for finding unused ref
%\nocite{*}  % cite all ref, for finding unused ref
\usepackage{biblatex}
\bibliography{references}

% Tenslotte wordt hyperref gebruikt voor pdf bestanden.
% Dit mag verwijderd worden voor de af te drukken versie.
\usepackage[pdfusetitle,colorlinks,plainpages=false]{hyperref}
\hypersetup{allcolors = black}
%%%%%%%
% Om wat tekst te genereren wordt hier het lipsum pakket gebruikt.
% Bij een echte masterproef heb je dit natuurlijk nooit nodig!
%\IfFileExists{lipsum.sty}%
% {\usepackage{lipsum}\setlipsumdefault{11-13}}%
% {\newcommand{\lipsum}[1][11-13]{\par Hier komt wat tekst: lipsum ##1.\par}}
%%%%%%%
\begin{document}
\begin{preface}
Although this thesis was finished with a strict planning I put onto myself, it was immensely fun to work on. From the destructive nature of fuzzing bugs to the fascinating topic of constraint solving, it all interested me and I had not a single moment where I had to push myself to start working on it. Nevertheless, this thesis would not have been possible without the following people.


\noindent Firstly, I would like to thank 
professor dr. Tias Guns for the guidance and the proposal of this fascinating topic,
ir. Ignace Bleukx for answering many questions, intensive thesis meetings, proofreading and the cleverness for coming up with the name of CTORM, 
dr. ir. Jo Devriendt for finding bugs within our bug finder, 
the rest of the CPMpy-team, 
Hakan Kjellerstrand for publishing a significant number of examples which we used as seeds,
friends for proofreading even all the way back from industrial engineering on campus De Nayer like ing. Simon Vandevelde.
Finally, I would like to thank my family for the support during my further studies.
\end{preface}

\tableofcontents*
\setcounter{tocdepth}{5} % this works wow! Now I have a clean TOC but still the pdf outline in depth

\begin{abstract}
This thesis presents a comparative study between three ways of finding bugs in CPMpy as a use case to examine which techniques are suitable for finding bugs in constraint programming languages. With these languages, problems (including logical and optimization) can be modeled and solved. CPMpy extends the modeling part of these problems to be done in a for most familiar programming language python and allows for a close connection to NumPy and the solvers. In CPMpy we will search for bugs where it may crash, hang or produce the wrong output. All of these are unwanted but the last ones do not show the user that a bug has occurred. 
The first technique to find bugs builds further on an existing paper to test solvers for SMT theories, which this paper converts to be able to test CPMpy with. 
A second technique uses output preserving equivalent changes to see whether the original result differs from the result of the modified program.
The final technique uses the concept of comparing the results of analog programs in order to detect any differentiations between any of the programs.

Of the 23 issues and questions submitted to the repository 19 turned to be bugs. The first technique finding 10 bugs, the second finding 13 bugs and the last one finding 11 out of the 19 found bugs. Resulting not a single technique able to find all bugs. With more development in constraint programming and CPMpy these techniques would help with finding bugs in the future. 


% voordelen automatisch bugs vinden? = not crusial info
% results Abstrakt is suppost to be a sneak peek not a spoiler
%The \texttt{abstract} environment contains a more extensive overview of
%the work. But it should be limited to one page.
\vspace*{\fill}
\noindent
\textbf{Keywords:} constraint programming, CPMpy, fuzz testing, bugs, STORM, metamorphic testing, differential testing
\end{abstract}

\begin{abstract*}
%
Deze masterproef stelt een vergelijkende studie voor tussen drie manieren om bugs te vinden met CPMpy als voorbeeld. Dit om te onderzoeken welke technieken geschikt zijn om bugs te vinden in programmeertalen voor beperkingen.
De eerste techniek bouwt verder op een bestaande paper om SMT-theorieën te testen via de tester STORM, deze paper converteert STORM naar een tester die om kan gaan met CPMpy om daar dan mee te kunnen testen.
Een tweede techniek maakt gebruik van resultaatgebonden equivalente wijzigingen om te evalueren of het oorspronkelijke resultaat verschilt van het resultaat van het gewijzigde programma. En ten slotte gebruikt de laatste techniek het concept van gelijkaardige programma's, om de resultaten hiervan te vergelijken om zo eventuele verschillen tussen de programma's te detecteren.

Geen van de gebruikte technieken resulteerde in een perfecte score rond de gevonden fouten. De eerste vond 10 fouten, de tweede 13 en de laatste 11 van de in totaal 19 gevonden fouten. Met verdere ontwikkelingen in CPMpy en de programmeertalen zullen nieuwe fouten gemaakt worden en hierbij zouden de technieken gebruikt kunnen worden om deze op te sporen.

%State of the art 
%'in deze masterproef stellen wij een vergelijkende studie voor om auto bugs te vinden in cpl met als voorbeeld taal de CPMpy written by Tia's Guns at al.
%Voordelen automatisch bugs (Tijdwinst, Safer programma)

\end{abstract*}

% Een lijst van figuren en tabellen is optioneel
%\listoffigures
%\listoftables
% Bij een beperkt aantal figuren en tabellen gebruik je liever het volgende:
\listoffiguresandtables
\lstlistoflistings
% De lijst van symbolen is eveneens optioneel.
% Deze lijst moet wel manueel aangemaakt worden, bv. als volgt:
\chapter{List of Abbreviations and Symbols}
\section*{Abbreviations}
\begin{flushleft}
  \renewcommand{\arraystretch}{1.1}
  \begin{tabularx}{\textwidth}{@{}p{14mm}X@{}}
  	
%Alphabetic pls
	CI/CD & Continuous Integration and Continuous Deployment, a pipeline for newly written code to repeatedly be built, tested, released, deployed and more. \\
    CP & Constraint Programming language sometimes also referred to as CPL \\
    CPL & Constraint Programming Language also referred to as CP \\
    CNF & Conjunctive Normal Form, which is a boolean formula written using conjunctions of distinctions. \\
    CSP & Constraint Satisfaction Problem is a problem with constraints and variables with a specific domain e.g., boolean, finite and others.\\
    CPMpy & Constraint Programming and Modeling language for Python.\\
    CVC & Cooperating Validity Checker a popular SMT-theorem prover \\
    LLVM & Although it looks like an abbreviation, it is not. LLVM is the name of a project focused on compiler and toolchain technologies. \\
    MIP & Mixed Integer Programming, a theory where decision variables are allowed to be integers \\
    MUS & Minimal Unsatisfiable Subset, the smallest subset possible that is not satisfiable \\
    NNF & Negation Normal Form, which is a boolean formula written using only  conjunctions, disjunctions and negations, with negations only occurring in literals. \\
    PUT & Program Under Test, the piece of code, application of program that is tested on for potential bugs. \\
    SMT & Satisfiability Modulo Theory, a generalization of SAT extend to more complex data forms like integers, strings and many more.\\
    SUT & Software under Test, analogue to PUT \\
  \end{tabularx}
\end{flushleft}

\section*{Symbols}
\begin{flushleft}
  \renewcommand{\arraystretch}{1.1}
  \begin{tabularx}{\textwidth}{@{}p{14mm}X@{}}
 	$\sim$ & Representation for a negation used by CPMpy\\
 	$\&$ & Representation for a “and” used by CPMpy\\
 	$\vert$ & Representation for a “or” used by CPMpy\\
  	$\neg$ & Mathematical representation for the logical negation \\
  	$\land$ & Mathematical representation for the logical “and” \\
  	$\lor$  & Mathematical representation for logical “or” \\
  \end{tabularx}
\end{flushleft}

% Nu begint de eigenlijke tekst
\mainmatter

\include{intro}
\include{chap-2} % CP, SAT and SMT 
\include{chap-3} % Fuzzing
\include{chap-4} % Detecting crucial parts in inputs
%\include{chap-5RQ} % Research questions
\include{chap-5} % Implementation
\include{chap-6} % results
\include{chap-7} % conclustion
%\include{chap-x} % futher work ?

% Indien er bijlagen zijn:
%\appendixpage*          % indien gewenst
%\appendix
%\include{app-A}

\backmatter
% Na de bijlagen plaatst men nog de bibliografie.
% Je kan de  standaard "abbrv" bibliografiestijl vervangen door een andere.
%\bibliographystyle{abbrv}
%\bibliography{references}
\nocite{MasterproefRubenKindt}
%\nocite{ThisThesis}
%\nocite{75Chicken} % Easter egg ;)
\printbibliography
\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
