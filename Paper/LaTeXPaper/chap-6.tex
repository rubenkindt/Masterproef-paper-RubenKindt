\chapter{Results}
\label{cha:res}
\label{res:Intro}
In this chapter we will see the results of all three of the created techniques, we will explain how we prevented frequently occurring bugs, discuss a diverse subset of found bugs with more detail. And end the chapter with a classification of all bugs and the reception of the bugs.

% multiple runs due toe randomness, how measured
% comparision with other fuzzers
% why did we (not) do code coverage ?
% timeout on the minizinc, but not on the ortools -> manuel work
% if stoppted before it was done due to timeout solvers didn't agree on the amount of solutions

\section{Running the tests}
\label{res:RunningTests}
\label{res:Specs}
Although, the specifications are not crucial since we did not do any speed benchmarking. It does give you, the reader, an idea of the performance. All tests were executed on an Ubuntu 20.04.5 LTS with 8GB RAM, an Intel core i5-3380M capable of 2.90GHz and a V-NAND SSD of 500GB 860 EVO Model MZ-76E500 through a SATA 3 connection. With each technique taking around a day to three days to run more than the nine thousand seed files once. Note that processing a seed once can mean that variants of that seed were run up to 100 times depending on the technique used.

%time when faults are found?

\subsection{Preventing the same bug from occurring frequently}
%these tools often gave the same error again causing the new bug to be hidden, se choice to catch some of the more prevelent bugs, If some one wishes to rerun (parts) It is best to remove those exceptions in order to see the full output
While the techniques were running, we noticed that once a bug was found by any of our techniques that same bug would occur frequently, but in a different seed causing our resulting logs to be cluttered with duplicates bugs. We were aware that this could occur and we originally wanted to use deduplication as described in subsection \ref{inputReduction:Deduplication} to get rid of the equivalent bugs. But after seeing 10 000 logs of the same bug, we changed from a reactive approach to a preventative approach. Once we noted a bug we tried to prevent it, for crashes this meant adding a try catch for the specific error. While for wrongly (un)satisfiable bugs we looked at special occurrences of keywords in the constraints we knew caused bugs, to then not log them. For example, a bug we will discuss soon had a specific string of characters, " == 0 == 0", making any problem wrongly unsatisfy. Being able to check the string of characters with knowing that it resulted in wrongly unsatisfiable solutions made it able for us to filter that bug as well. Luckily, with these restrictions on the output logs we were able to filter out most duplicate bugs, this is not an ideal solution but it worked well enough. The ideal solution would be that the fuzzer has knowledge of the already found bugs and reject them, techniques like these do exist but would bring us to far from the scope of the thesis. Although, less efficient the techniques could be used for detecting an error, fixing them and then rerunning for the next bug instead of adding exceptions.

\section{Results: found bugs}
\label{res:bugs}
%\todo{19 bugs is af h van welke definitie men volgt, met de onze komen we aan 19}
In total we found 19 bugs, three of which were already known in one form or another as an issue. Of those bugs some of them were easy fixes, some were a bit harder and required more time to solve. Depending on the definition of a bug the number of found bugs would differ with the definition followed in this paper 19 bugs remain out of the the 22 submitted. At the time of writing not al bugs are resolved (some are just reported days ago), but we look in anticipation how those will be solved. For now, let us look at some of the most interesting bugs we found. In order to do this, we will work with the four components we defined earlier in subsection \ref{CP:CPMpy}, this being: the model, the transformations, the solver interface and the solvers themselves as seen in figure \ref{fig:4ComponentsOfCPMpy}.


\subsection{Double Not}
\label{res:bug:DoubleNot}
The first bug we discovered was our "double not"-bug, a bug where we ask CPMpy to solve the constraints "X==3 and not(not(X==3))". Clearly this solution is trivial, set variable 'X' equal to 3 and the problem would be satisfied. However not all CPMpy solver did agreed with this, both OR-Tools and Gurobi said that this problem was unsatisfiable. 

This was due to a process within CPMpy responsible for creating a flat normal form. Not all solver used by CPMpy allow an arbitrary nesting of constraints as described by the documentation of CPMpy\footnote{\url{https://cpmpy.readthedocs.io/en/latest/behind_the_scenes.html}}. It is for that reason that CPMpy flattens the constraints to what they call 'flat normal forms' as the similar definition of SAT. But, with a disclaimer that this definition does not formally exists for CP languages to their knowledge, a statement which we agree with. With this flattened form CPMpy can directly call the solvers or do the last changes needed for the specific solver via the solver interface on the flattened constraints to then send it to the respective solver \cite{CPMpyGithub}. 

Those not's get translated to two comparison with a zero "== 0", but in the normalizing process that a comparison withing a comparison was not handled correctly. Causing a disappearance of a single "not", which in turn resulted the original constraint converted to "X==3 and not(X==3)". When this gets sent to OR-Tools or Gurobi they correctly say that the problem is unsatisfiable. The other solvers, mainly MiniZinc's subsolvers, were not affected by this bug due to not using this normalizing process. Although, this normalizing process was subjected to unit tests, these tests contained an incorrect output causing the bug to remain hidden. This bug was only caught using CTORM, due to its frequent use of adding not's and and's. But we believe it could have been caught in the metamorphic testing if we had thought of adding a relevant metamorphic transformation or in the differential testing if a seed had a double "not" in its constraints. 

A showcase of this double not bug can be seen in listing \ref{lst:Bug:DoubleNot}, where a variable 'X' is created on line 3 with a lower bound (lb) of zero and an upper bound of 9 (ub). Then, add the constraint "X == 3" to a created model on line 5 with the "+=" and the same constraint with a double negation on the next line. Remember that CPMpy uses '$\sim$' as a negation. We then see the different solvers solve the same model with a different exit status, unsatisfiable for OR-Tools and Gurobi and feasible for a MiniZinc subsolver. Feasible is a differentiation made by CPMpy within satisfiable with the other option being optimal both explain themselves. This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/142}{142}.

\label{lst:Bug:DoubleNot}
\begin{lstlisting}[language=python, caption={The "double not"-bug.}]
	from cpmpy import *
	
	X = intvar(lb=0, ub=9)
	m = Model()
	m += X == 3
	m += ~(~(X == 3)) # double negation 
	
	m.solve(solver="gurobi")
	print(m.status().exitstatus.name) # UNSATISFIABLE
	
	m.solve(solver="ortools")
	print(m.status().exitstatus.name) # UNSATISFIABLE
	
	m.solve(solver="minizinc:chuffed")
	print(m.status().exitstatus.name) # FEASIBLE	
\end{lstlisting}

\subsection{Negation of Global functions}
\label{res:bug:NegatedGlobal}
A second bug related to the use of not's were the crashes of the negated global functions. Where negations of global functions like "not(AllDifferent(argList))" would crash with a maximal recursion depth. As the normalizing of a negated global function would be handled with adding a "== 0" to it, instead of decomposing the global function and negating that. The action of adding a "== 0" did not change the constraint and on the next normalizing of the left part of the comparison "global function == 0", the same would happen. The solution was, as mentioned to decompose the global function, which was suggested in the comments together with a commented out throw of an not-implemented error. The entire function was labeled as work in progress, but the CPMpy-team expected it to work for this use case as they used it in their reification process. The reason it worked in this process was due to a shortcut not being taken, which the negation of global functions did do, therefore exposing the bug only in the latter case.

It was again due to the normalizing not being used for MiniZinc's subsolvers that the bug only occurred when using OR-Tools and Gurobi as solvers. And this bug was quickly found by CTORM since it uses a significant number of not's. Due to the metamorphic relation of adding "!= 0" after some constraints the metamorphic tests did find it as well. However, it did not get found by our differential tests simply because no examples negated their global functions, as such a negation is rarely useful. 


A showcase of this bug can be seen in listing \ref{lst:Bug:NotGlobal}, where a variable "pos" is created on line 3 with a shape of 3 meaning that "pos" will be an array of length 3. After creating an empty model a negation of a global function "AllDifferent" is added to a created model on line 5. With this we ask to find not all different values of the array "pos", which will be satisfies as long as one of the elements withing the array has the same value as one of the other elements in the array. For example, array "[1 2 2]" would satisfy. Subsequently, a MiniZinc subsolver is used to solve the problem which returns feasible on respectively line 7 and 8. However, when asking the same for solver Gurobi it will crash, analog with the next line if the previous one would not have crashed the program. This bug report can be found in the GitHub repository issue number  \href{https://github.com/CPMpy/cpmpy/issues/143}{143}.

\label{lst:Bug:NotGlobal}
\begin{lstlisting}[language=python, caption={The "negation of global functions"-bug.}]
	from cpmpy import *

	pos = intvar(lb=0, ub=5, shape=3)
	m = Model()
	m += ~AllDifferent(pos)
	
	m.solve("minizinc:chuffed")
	print(m.status().exitstatus.name) # FEASIBLE

	m.solve("gurobi") # crash
	m.solve("ortools") # would crash as well
\end{lstlisting}

\subsection{Power function of Gurobi}
\label{res:bug:Power}
Now that we have seen two bugs in the normalization part of CPMpy, which both fit in the transformation component of CPMpy. It is time to look at the solver interface and some bugs we found there. A first one was a bug where the solver Gurobi would crash if we gave a base variable in the power function which had a negative lower bound. A lower bound meaning that the variable was not permitted lower that that bound. All other solver would be able to solve "pow(X, 2) == 9" with the variable 'X' defined with a lower bound of -5 and a higher bound of 5. But Gurobi did (and still does) not allow this throwing an error as a result as can be seen in listing \ref{lst:Bug:PowGurobi}.

This bug was found with the CTORM implementation because there was a seed file which contained this power function with a negative lower bound in the base. However, the solver used to solve this problem was not Gurobi meaning that the bug was not discovered when written. The original example can be found at the CPMpy repository's csplib examples\footnote{\url{https://github.com/CPMpy/cpmpy/blob/b60310d7962bc7631bcf0b9024140e47c1fb302e/examples/csplib/prob005_auto_correlation.py}}. We do not think that CTORM would have found it, if it was not in the seed file to begin with. This because CTORM does not create new variables nor modifies any bounds of variables. The bug was also not found using the metamorphic tests, but we do believe that if we had written a metamorphic relation for the power function or one where we changed some bounds of variables that we could have found this bug. And since the problem was already in the seed file to begin with the differential testing did find the bug and logged it. This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/149}{149}.

\label{lst:Bug:PowGurobi}
\begin{lstlisting}[language=python, caption={The "power function of Gurobi"-bug.}]
	from cpmpy import *

	m = Model()
	X = intvar(lb=-5, ub=5)
	m += pow(X, 2) == 9

	m.solve(solver="gurobi") # GurobiError
\end{lstlisting}



\subsection{Wrong bound value Error}
\label{res:bug:WrongBounds}
A second bug we found in the solver interface was a missing check on the variable type, this time not in Gurobi but in the PySAT implementation. When asking for a check if a sum of booleans matches a specific variable and that variable happens to be an integer instead of a boolean naturally the SAT solver, which only support boolean satisfiability problems, will complain. In this specific case it was a follow-up function still within CPMpy that crashed. This with wrong bounds since it expected a bound of only two possibilities, a boolean, but got a larger bounds. On all other places we could find check with an error that would be thrown. But on this spot it was missed, which was quickly patched after reporting it.

Although, CTORM was run with PySAT's subsolvers, it did not find this bug simply due to a check of (un)satisfiability of the original problem at the start of the program. This check would often crash with PySAT's subsolvers since almost all seeds were written with a CP solver in mind. The technique would assume that the original seed was faulty to start with and continue with another solver or another seed. The same happened with the metamorphic tests where we needed to know the (un)satisfiability of the model before the changes, where it would crash again on the original model. Since those crashes were not logged in both techniques, we did not find it with this techniques. The bug did get discovered with the differential tester where each crash did get logged on top of all differences. This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/150}{150}.

%\subsection{Circuit of one} % remove this bug from the txt ?
%\label{res:bug:Circuit}
%On top of bugs related to specific solver or a group of solvers treated differently like the first two bugs. We also found bugs that would be thrown unrelated to which solver was used to solve the problem. Which brings us to the bug where we discovered that creating a global function, namely circuit, with only one entry would it crash with a not subscriptable error. This bug can be seen as an user caused error and be dismissed, but the CPMpy-team agreed saw it the same way. They marked it as a bug and added a small check.
%
%\todo{which fuzzers found it?}
%
%This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/157}{157}.

\subsection{Naming variables}
\label{res:bug:Naming+andImport}
Now that we have seen bugs occur in both the transformations and the solver interface let us look at a bug we have found in the model component of CPMpy. 

CPMpy has multiple features like importing, exporting models, adding names variables (not to be confused with the local variables as seen on line 12 in listing \ref{lst:SendMoreMoneyCPMpy}) and more. The adding of the name is to make sure that after an export and import the given variable names are still remembered among other reasons, like to be able to give the solver the variable names. When the programmer does not give a name to a variable as we did on line 12 in listing \ref{lst:SendMoreMoneyCPMpy} with the missing "name=''" attribute in the "intvar" function. Then CPMpy adds a name to the variable without telling the programmer. these variables start with "BV" for boolean variables and "IV" with integer variables and each get appended with their respective incrementing number to prevent similar names. This because reusing variable names is dangerous when the solvers use this name to differentiate variables from each other.
%\todo{is dit slecht uitgelegd?}

This brings us to the bug; it occurs when importing a model with automatic naming where those counters did not get updated. Meaning that when a new variable was created with automatic naming it would have an overlapping variable name with a variable that was previously imported. When a solver was then called it would treat both variables as the same resulting in potential wrongly unsatisfiable solutions. The use case is a bit farther from the normal use case a programmer would go through. Nevertheless, this was not considered a misuse of CPMpy according to the developers and at the time of writing a pull request got proposed in which the import function got extended to check the highest occurrence of the boolean and integer counter. This highest occurrence will then be used for the counters of new variables.

A similar and almost related bug is in the naming of variables, when creating them starting with strange symbols like '+', '\%' or others some solvers would crash. Most solvers would happily solve with these names, but all MiniZinc's subsolvers crashed with a syntax error when handling the input. This due to transformation of our model to the text-based FlatZinc for the subsolver, it can no longer differentiate between the variable name and the code. It therefore crashed when seeing anything that could be interpreted differently than a variable name. MiniZinc does state that identifiers are not allowed to contain special characters, which other solvers and CPMpy do allow. A solution is still being discussed at the time of writing.


In listing \ref{lst:Bug:+} this bug of strange symbols is showcased. With a variable 'i' being declared on line 3 with a lower and higher bound respectively 0 and 5. To then define a name manually and name it '+', this in contrast with the previous listings where CPMpy used automatically naming of the variables.  Due to this strange naming of variables MiniZinc will crash with a syntax error on line 10 while it solved the constraint fine on line 7.

\label{lst:Bug:+}
\begin{lstlisting}[language=python, caption={A bug showcasing that the naming of CPMpy is looser then MiniZinc.}]
	from cpmpy import *
	
	i = intvar(lb=0, ub=5, name="+")
	m = Model()
	m += i > 0
	
	m.solve(solver="ortools")
	print(m.sstatus().exitstatus.name) # OPTIMAL
	
	m.solve(solver="minizinc:chuffed") # crash by syntax error
\end{lstlisting}

Both of these bugs were not caught by CTORM nor the differential testing, since they do not create new variables. But did get caught by the metamorphic tests, the first bug was caught because we imported a seed file where automatic naming was done after which we created a variable too with this process, resulting in the the bug. the second one is a bit more embarrassing to write down, as we created a bug in the metamorphic tester which resulted in the (unintentionally) creation of variables starting with a '+'. Our own bug caused us to find a bug in CPMpy. We still label it a caught bug because the automatic bug catcher did find it, although only by a fault we made. This bug reports can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/158}{158} and \href{https://github.com/CPMpy/cpmpy/issues/162}{162} respectively.


\subsection{MiniZinc returning zero}
\label{res:bug:MinizincZero}
Our last bug we will discuss in detail was a bug we found with a solver themselves, namely with some MiniZinc subsolver. While solving certain problems with MiniZinc's subsolvers Gecode and others it would sometimes crash with the error that it stopped without output. After reporting it turned out to be a known bug in the MiniZinc Python repository for Windows operating systems and was fixable with setting some path variables correctly. Which CPMpy may solve by adding a warning when this happens or by documenting it.
Given that this problem is an installation problem, all techniques were able to find the bug. This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/156}{156}.

%\subsection{Unsatisfiable Gurobi} % boring bug
%\label{res:bug:UnsatGurobu}
%Our last bug we will discuss is a bug that was found by all three techniques
%
%
%This bug report can be found in the GitHub repository issue number \href{https://github.com/CPMpy/cpmpy/issues/168}{168}.


%\subsection{Solver lookup bug} % boring bug
%\label{res:bug:solverLookup}
%solverlookup() was during development of the tester = manual testing, 

\todo{bug \href{https://github.com/CPMpy/cpmpy/issues/163}{163} would be a fun explanation for the thesis, but lacks a bug. atm it's a note in \ref{impl:Meta}}


\section{Classifications}
Now that we have seen in depth explanations of some bugs let us give an overview of all found bugs by classifying them based on place, type of the bugs, which solver caused the bugs and which technique found the bugs. The bug number refers to the issue number on GitHub and is a hyperlink to that bug, the second column is a short description of the bug and then the table specific classification follows.

% added above the text that refference it, to prevent tables being back to back
\begin{table}[]
	\centering
	\caption{Table discussing in which CPMpy component the bug was found. With 4 bugs in the model, 7 bugs in the transformations, 7 bugs in the solver interface and one a solver were found.}
	\label{tab:bug:placeComponent}
	\begin{tabular}{lll}
		\hline
		BugNr & Bug description                                         & Place of the bug \\ \toprule
		\href{https://github.com/CPMpy/cpmpy/issues/142}{142} & double not gives unsat                            & Transformations \\
		\href{https://github.com/CPMpy/cpmpy/issues/143}{143} & negating global functions crashes                 & Transformations \\
		\href{https://github.com/CPMpy/cpmpy/issues/145}{145} & solvers lookup crashes                            & Model            \\
		\href{https://github.com/CPMpy/cpmpy/issues/149}{149} & power function with negative lower bound crashes  & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/150}{150} & wrong bound causes a crash                        & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/152}{152} & boolean variable does not support implies         & Model            \\
		\href{https://github.com/CPMpy/cpmpy/issues/153}{153} & Gurobi does not run and gave the wrong nr of sol  & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/154}{154} & JSON Decoder error                                & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/155}{155} & list has no shape                                 & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/156}{156} & MiniZinc returns zero causes a crash              & Solver           \\
		\href{https://github.com/CPMpy/cpmpy/issues/157}{157} & circuit of one element crashes                    & Transformations  \\
		\href{https://github.com/CPMpy/cpmpy/issues/158}{158} & identical variable name can cause wrongly unsat   & Model            \\
		\href{https://github.com/CPMpy/cpmpy/issues/159}{159} & unhandled Gurobi exit status 9                    & Solver interface \\
		\href{https://github.com/CPMpy/cpmpy/issues/161}{161} & two separate references for the same variable     & Model            \\
		\href{https://github.com/CPMpy/cpmpy/issues/162}{162} & CPMpy is looser with variable names than MiniZinc & Solver interface \\
		%\href{https://github.com/CPMpy/cpmpy/issues/163}{163} & cyclic expression tree got generated              & Model            \\
		\href{https://github.com/CPMpy/cpmpy/issues/164}{164} & malloc() failure due to unset bounds              & Transformations  \\
		\href{https://github.com/CPMpy/cpmpy/issues/165}{165} & memory violation segmentation fault               & Transformations  \\
		\href{https://github.com/CPMpy/cpmpy/issues/168}{168} & unsatisfiable Gurobi                              & Transformations  \\
		\href{https://github.com/CPMpy/cpmpy/issues/170}{170} & unsatisfiable due to flattening                   & Transformations  \\ \bottomrule        
	\end{tabular}
\end{table}

%\subsection{Place of the bug}
As can be seen in table \ref{tab:bug:placeComponent} the cause of which component failed is well spread out withing CPMpy. 
With 4 bugs in the model, 7 bugs in the general transformations, 7 bugs in the solver interface and one a solver related bug. The one and only solver related bug we found was the one we discussed in subsection \ref{res:bug:MinizincZero}, which was already known by MiniZinc. We would have hoped to find more bugs in the solvers themselves and it was our aim with this thesis. But either these techniques are not sufficient or most bugs are already found before release or are already reported and solved.
If we look at the reported issues withing the GitHub repository of Google's OR-Tools, we find no significant bugs towards the (un)satisfiability or any wrong output by the solver. Which makes us speculate that Google does extensive testing on that front or even have used the techniques used in this thesis. This last one is likely as Google created multiple own fuzzers, which we discussed in subsection  \ref{fuzzing:OtherFuzzers}. Extensive testing is most likely also done by other solvers since they would probably lose reputation if their solver would be proven to not produce the correct result.

%\subsection{What did the bug cause}
Like the authors of STORM, we focused with our techniques on the critical faults, this being the wrongly satisfiable, the wrongly unsatisfiable and the wrong number of solutions. Since these critical bugs are harder to detect for the final user than a crash, timeout or other bug. Out of the 19 bugs found 6 of them fall in our category of critical while the other 13 where all crashes as can be seen in table \ref{tab:bug:fault}. Most of those 6 critical bugs were situations where the solver wrongly outputted that a solution was unsatisfiable and there was only one bug where we could find both a wrongly satisfiable and wrongly unsatisfiable solution.

\begin{table}[]
	\caption{Table discussing what type of fault was caused by which the bugs.}
	\label{tab:bug:fault}
	\centering
	\begin{tabular}{lll}
		\hline
		BugNr & Bug description                                           & Type of fault   \\ \toprule
		\href{https://github.com/CPMpy/cpmpy/issues/142}{142} & double not gives unsat                            & wrongly unsat   \\
		\href{https://github.com/CPMpy/cpmpy/issues/143}{143} & negating global functions crashes                 & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/145}{145} & solvers lookup crashes                            & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/149}{149} & power function with negative lower bound crashes  & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/150}{150} & wrong bound causes a crash                  & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/152}{152} & boolean variable does not support implies         & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/153}{153} & Gurobi does not run and gave the wrong Nr of sol  & wrong Nr of sol \\
		\href{https://github.com/CPMpy/cpmpy/issues/154}{154} & JSON Decoder error                                & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/155}{155} & list has no shape                                 & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/156}{156} & MiniZinc returns zero causes a crash              & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/157}{157} & circuit of one element crashes                    & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/158}{158} & identical variable name can cause wrongly unsat   & wrongly unsat   \\
		\href{https://github.com/CPMpy/cpmpy/issues/159}{159} & unhandled Gurobi exit status 9                    & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/161}{161} & two separate references for the same variable     & wrongly unsat   \\
		\href{https://github.com/CPMpy/cpmpy/issues/162}{162} & CPMpy is looser with variable names than MiniZinc & crash           \\
		%\href{https://github.com/CPMpy/cpmpy/issues/163}{163} & cyclic expression tree got generated               & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/164}{164} & malloc() failure due to unset bounds              & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/165}{165} & memory violation segmentation fault               & crash           \\
		\href{https://github.com/CPMpy/cpmpy/issues/168}{168} & wrongly unsatisfiable Gurobi                      & wrongly unsat   \\
		\href{https://github.com/CPMpy/cpmpy/issues/170}{170} & wrongly (un)satisfiable due to flattening         & wrongly (un)sat \\ \bottomrule
	\end{tabular}
\end{table}

%\subsection{Which solver was responcible for the bug}
When looking at table \ref{tab:bug:Solver} we can see which bug was caused by which solver or if it was a solver independent bug. Were we see 5 bugs unrelated to any solver, that OR-tools only occurred together with Gurobi and that OR-Tools and Gurobi didn't share any bugs found with MiniZinc or PySAT. Meanly because OR-Tools and Gurobi share more transformation code than any other solver. We also see that Gurobi occurs the most among out our bugs, this often due to edge cases on Gurobi's implementation. Although, it could be coincidental that we found more Gurobi bug than any other we speculate that the software being proprietary makes it less clear-cut to be implemented in CPMpy.

\begin{table}[]
	\centering
	\caption{Table discussing which bug was caused by which solver or if it was a solver independent bug.}
	\label{tab:bug:Solver}
	\begin{tabular}{lll}
		\hline
		BugNr & Bug description                                           & Which solver caused it?\\ \toprule
		\href{https://github.com/CPMpy/cpmpy/issues/142}{142} & double not gives unsat                            & OR-Tools and Gurobi          \\
		\href{https://github.com/CPMpy/cpmpy/issues/143}{143} & negating global functions crashes                 & OR-Tools and Gurobi          \\
		\href{https://github.com/CPMpy/cpmpy/issues/145}{145} & solvers lookup crashes                            & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/149}{149} & power function with negative lower bound crashes  & Gurobi                       \\
		\href{https://github.com/CPMpy/cpmpy/issues/150}{150} & wrong bound causes a crash                  & all PySAT subsolvers         \\
		\href{https://github.com/CPMpy/cpmpy/issues/152}{152} & boolean variable does not support implies         & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/153}{153} & Gurobi does not run and gave the wrong nr of sol  & Gurobi                       \\
		\href{https://github.com/CPMpy/cpmpy/issues/154}{154} & JSON Decoder error                                & MiniZinc's subsolver osicbc  \\
		\href{https://github.com/CPMpy/cpmpy/issues/155}{155} & list has no shape                                 & Gurobi                       \\
		\href{https://github.com/CPMpy/cpmpy/issues/156}{156} & MiniZinc returns zero causes a crash              & multiple MiniZinc subsolvers \\
		\href{https://github.com/CPMpy/cpmpy/issues/157}{157} & circuit of one element crashes                    & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/158}{158} & identical variable name can cause wrongly unsat   & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/159}{159} & unhandled Gurobi exit status 9                    & Gurobi                       \\
		\href{https://github.com/CPMpy/cpmpy/issues/161}{161} & two separate references for the same variable     & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/162}{162} & CPMpy is looser with variable names than MiniZinc & all MiniZinc subsolvers      \\
		%\href{https://github.com/CPMpy/cpmpy/issues/163}{163} & cyclic expression tree got generated               & solver independent           \\
		\href{https://github.com/CPMpy/cpmpy/issues/164}{164} & malloc() failure due to unset bounds              & multiple MiniZinc subsolvers \\
		\href{https://github.com/CPMpy/cpmpy/issues/165}{165} & memory violation segmentation fault               & multiple MiniZinc subsolvers \\
		\href{https://github.com/CPMpy/cpmpy/issues/168}{168} & wrongly unsatisfiable Gurobi                      & Gurobi                       \\
		\href{https://github.com/CPMpy/cpmpy/issues/170}{170} & wrongly (un)satisfiable due to flattening         & OR-Tools and Gurobi          \\ \bottomrule
	\end{tabular}
\end{table}

%\subsection{Which technique found the bug}
Our last table \ref{tab:bug:Technique} shows the techniques finding which bug. CTORM found 10 bugs, metamorphic testing found the most bugs at 13 and differential testing found 11 out of the19 found bugs. This shows that none of the techniques are perfect on their own, but that metamorphic testing could come close if more work was put in creating metamorphic relations. Although, this does require creativity and manual labor instead of the other automated techniques.

\begin{table}[]
	\centering
	\caption{Table discussing which technique found the bug. CTORM found 10 bugs, metamorphic testing found the most bugs at 13 and differential testing found 11 out of the 19 found bugs.}
	\label{tab:bug:Technique}
	\begin{tabular}{lllll}
		\hline
		BugNr & Bug description                                           & \multicolumn{3}{c}{\centering  Bug found by} \\ \toprule
		\href{https://github.com/CPMpy/cpmpy/issues/142}{142} & double not gives unsat                            & ctorm &       &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/143}{143} & negating global functions crashes                 & ctorm & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/145}{145} & solvers lookup crashes                            &       &       & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/149}{149} & power function with negative lower bound crashes  & ctorm &       & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/150}{150} & wrong bound causes a crash                  &       &       & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/152}{152} & boolean variable does not support implies         &       & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/153}{153} & Gurobi does not run and gave the wrong nr of sol  &       &       & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/154}{154} & JSON Decoder error                                & ctorm & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/155}{155} & list has no shape                                 & ctorm & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/156}{156} & MiniZinc returns zero causes a crash              & ctorm & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/157}{157} & circuit of one element crashes                    &       & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/158}{158} & identical variable name can cause wrongly unsat   &       & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/159}{159} & unhandled Gurobi exit status 9                    & ctorm &       & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/161}{161} & two separate references for the same variable     & ctorm & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/162}{162} & CPMpy is looser with variable names than MiniZinc &       & meta  &      \\
		%\href{https://github.com/CPMpy/cpmpy/issues/163}{163} & cyclic expression tree got generated               &       & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/164}{164} & malloc() failure due to unset bounds              &       & meta  &      \\
		\href{https://github.com/CPMpy/cpmpy/issues/165}{165} & memory violation segmentation fault               &       & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/168}{168} & wrongly unsatisfiable Gurobi                      & ctorm & meta  & diff \\
		\href{https://github.com/CPMpy/cpmpy/issues/170}{170} & wrongly (un)satisfiable due to flattening         & ctorm & meta  &      \\ \bottomrule
	\end{tabular}
\end{table}


\section{Reception to the bugs} 
As mentioned in section \ref{fuzzing:OpinionsAgainstFuzzing} there are multiple views on automated bug catching. We could have thrown all our found bugs on the issue page of GitHub without further context. Which would have meant more work for the CPMpy-team and then we could perhaps have seen some negative opinions on fuzzing. 
Although, we submitted 22 bugs or questions withing a time span of 2 weeks with deobfuscating the inputs and some explanation of what happened to get the bug, we saw a grateful welcome. Similar to what was described in the second part of section \ref{fuzzing:OpinionsAgainstFuzzing}. 
For example, the "double not"-bug\footnote{\url{https://github.com/CPMpy/cpmpy/issues/142}} was called a serious bug and a great find and 
the "negation of global functions"-bug\footnote{\url{https://github.com/CPMpy/cpmpy/issues/143}} was described as an unexpected bug and another great find.
%\todo{find out if this is useful addition of the thesis?}

%\section{unsat}
%due to the way of importing the file a lot of edge problems become sat or unsat



\section{Conclusion}
\label{res:conclusion}
In this chapter we have seen that the techniques frequently output already found bugs, since none of the techniques have knowledge of already found bugs. But after filtering previously found bugs the techniques perform well and found 19 bugs in CPMpy. We have seen some bugs in detail with most of them already fixed, due to being easily fixable. We have seen that most bugs were related to the CPMpy code and only one responsible by an external solver. We suspect this lack of external solver bugs to be caused by well written and tested solvers. We have shown that we found crashes up to critical bugs like wrongly (un)satisfiable solutions and wrong number of solutions with over a variety of solvers. Of all the techniques used, metamorphic testing came just above the other two techniques with 13 found bugs while CTORM found 10 and the differential testing found 11 bugs out of 19. And finally, we noted the grateful welcome of bugs by the CPMpy-team.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
