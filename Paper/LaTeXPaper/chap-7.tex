\chapter{Conclusion and future work}
\label{cha:7:conclusion}
\label{con:intro}
In this chapter will conclude the thesis by discussing the achievements, the limitations of the techniques used and end with possible exiting future work.

\section{Achievements}
\label{con:Achievements}
This thesis achieved to find numerous bugs withing CPMpy this with the use of multiple techniques. As discussed in section \ref{res:Classifications}, some bugs where found by multiple techniques. Out of the 19 bugs found 10 were found by CTORM, 13 by metamorphic and 11 by differential testing. These bugs were mostly found well spread within CPMpy, but very little where found in the solver themselves. A third of the time the bugs resulted in a critical bug, this being a wrongly (un)satisfiable or the wrong amount of solutions presented. The other two-thirds of the bugs resulted in a crash. Often caused by smaller edge case where CPMpy did not follow the specific solver's specifications, for example the power bug of Gurobi in section \ref{res:bug:Power}. None of the techniques got a perfect score meaning that when looking for all bugs a combination of tools will need to be made as clarified in subsection \ref{res:TechniqueToFindBug}.
% addition to other form of testing

The techniques almost achieved semi-automatic testing with the corresponding advantages of ease of use, time savings and more while extensive testing. Both CTORM and differential testing have potential to become fully automatic testing tools after fixing the repeated logging of already found bugs.

%semi automatic more on that later in the next section 
%found metamorphic testing yet to be a bit better compared to the others
%voordelen automatisch testen: tijdswinst, safer program

\section{Limitations}
\label{con:Limitations}
This problem of frequently finding the same bug is a problem, since it clogs the output with repeated or similar bugs, making it harder to find new bugs. The first solution proposed in this thesis was to deduplicate bugs with the technique seen in subsection \ref{inputReduction:Deduplication}. But during testing a preventative approach seemed  favorable compared to the reactive approach of filtering out known bugs. Although the filters currently in use work, they require the developer to run a tester see what the results are and add a try catch for the most occurring bugs. Ideally this manual creation of filters is done automatically by adding the knowledge of the already found bugs to the tester. 

Another limitation to the testers is specifically with the metamorphic testing, in this technique metamorphic relations need to be manually created. These relations are then used to change constraints to an equivalent but different constraint. With more particular relations the technique would have been able to find at minimum the "double negation"-bug and the power bug of Gurobi as well. But after implementing 30 metamorphic relations creativity for new relations starts to dwindle down. A second limitation will be that these relations will need to be updated or added after each new addition to CPMpy, which results in more work for the developer and another step away from automation.

%add exception once a bug is found for that specific bug and rerunning again manual work
%-> best use during development instead of when a release is wanted. 
%Which may not be a bad way of working.

While working with seeds is the better than generating inputs the inputs themselves as discussed in subsection \ref{fuzzing:generationMutation}, it did bring limitations with it. Those limitations being the availability, complexity and diversity of the seeds. For example, the bug with the negation of global constraints was not found using differential testing since none of the over nine thousand seed files had any negation of a global constraint. This was a limitation created by using seed files that originated from examples of CPMpy.

%Another limitation is with the seeds, while we did discuss the advantages of working with self generating inputs compared to using existing inputs in  Where we working with seeds did limit us 
%problems limited by global fucntions of used seeds (somewhat fine),
%diversity of the seed files  

%\subsection{CTORM} NOT USED ATM !
%STORM originated from as a SMT fuzzer, we changed it to be able to handle CP's 
%but it still modified problem models like it was a SMT; With conjunctions and negations
%Techniques are best applied during development, since Ctorm of to often detects the already found bugs
%only 'and' and 'not' combinations Just like STORM

%\subsection{Metamorphic testing}
%bug wrong bound would have been found if we logged the crashes of the original file 

%did not find ~(~()) as we didn't think to check it specifically, we did check ~=0
%all checks ? + combo-able

%meta testing requires extra manual work
%manual written (= work, although not much work), own choice on how complex you make the relations(simple ones work too), still need the creativity, all relations seem to be "why would this crash this is pointless to write" but do crash sometimes

%created cyclic expressions, a bug that was discovered by Jo DeVriendt in bug number \href{www.todo.be}{163}

\section{Future work}
\label{con:FutureWork}
With new code new bugs will appear so the work of a developer will never be done when it comes to finding bugs. Rerunning the techniques could result in even more interesting bugs. 
%new code = new bugs
On top of solving the limitations specified in the previous section \ref{con:Limitations},
%adding knowledge of already found bugs while searching for the next bug
a look at testing the configuration space would be an interesting addition to the preformed study. This testing of configuration space was briefly mentioned in section \ref{fuzzing:testingWithFuzzers} where the authors of "Fuzzing smt solvers via two-dimensional input space exploration" \cite{42FalconFuzzingConfigurationSettingsAndNormal} also fuzz test the configuration options of the PUT. Within CPMpy a lot of extra solver parameters are available depending on the solver used, which form a nice basis to fuzz the configuration space on top of the inputs.
%Which would come closer to what Ignace Bleukx et al. did in \cite{74bleukx2022model}, but instead of speeding up searches we would be trying to find bugs.
%we only did configuration space of the solvers, it may be interesting to know how CP's including CPMpy react to changes or attributes that tell the solver to solve in a special way 
Finally, an extension to other languages would be possible as a future work as well.

%\section{Conclusion} concluding chapter  doesn't need a conclusion.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
